{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ixia","text":"<p>Ixia is a cryptographically secure RNG library. It mainly merges <code>secrets</code>' security with <code>random</code>'s versatility, but also adds some of its own functions, such as <code>ixia.passphrase()</code>, <code>ixia.shuffled()</code> or <code>ixia.universe_rand()</code>. All random values are generated using <code>urandom</code> (or <code>BCryptGenRandom</code> on Windows).</p>"},{"location":"#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<p>While supporting Python 3.8+, Ixia is based on the Python 3.12 implementation of the <code>random</code> module. The following changes have been made to the module since Python 3.8:</p> <ul> <li><code>getrandbits</code> accepts 0 for <code>k</code></li> <li><code>choices</code> raises a <code>ValueError</code> if all weights are zero</li> <li><code>sample</code> has a new <code>counts</code> parameter</li> <li><code>gauss</code>, <code>expovariate</code> and <code>normalvariate</code> have default parameter values</li> <li><code>binomialvariate</code> was added</li> </ul> <p>Additionally, Ixia executes 3.9+ deprecations, thus:</p> <ul> <li><code>ixia.rand_range</code> doesn't convert non-integer types to equivalent integers</li> <li><code>ixia.sample</code> doesn't support <code>set</code> as a sequence type</li> <li><code>ixia.shuffle</code> doesn't support the <code>random</code> parameter</li> </ul> <p>On the following pages of this documentation, function signatures often mention the <code>Number</code> type\u2014that's simply an alias to <code>Union[int, float]</code>.</p>"},{"location":"#credits","title":"Credits","text":"<ul> <li>The original <code>random</code> module documentation &amp; implementation: Python Software Foundation</li> <li><code>universe_rand</code> implementation: qexat</li> </ul>"},{"location":"date_and_time/","title":"Date &amp; Time","text":""},{"location":"date_and_time/#ixiarand_date","title":"<code>ixia.rand_date</code>","text":"<p><pre><code>Datelike = str | int | tuple[int, int, int] | datetime.date | datetime.datetime\ndef rand_date(start: Datelike, end: Datelike | None = None) -&gt; datetime.date\n</code></pre> Returns a random date between <code>start</code> and <code>end</code> (both inclusive).</p> <p>The inputs can be of the following types:</p> <ul> <li>ISO format string (e.g. \"2023-03-12\")</li> <li>year integer (<code>rand_date(2020, 2022)</code> \u21d4 <code>rand_date(\"2020-01-01\", \"2022-12-31\")</code>)</li> <li>(year, month, day) tuple</li> <li><code>datetime.date</code> object</li> <li><code>datetime.datetime</code> object</li> </ul> <p>If <code>end</code> is not specified, it's gonna be set to the end of the start date's year, (e.g. <code>rand_date(\"2023-09-01\")</code> \u2192 <code>rand_date(\"2023-09-01\", \"2023-12-31\")</code>).</p>"},{"location":"date_and_time/#ixiarand_time","title":"<code>ixia.rand_time</code>","text":"<pre><code>Timelike = (\nstr\n| int\n| tuple[int, int]\n| tuple[int, int, int]\n| tuple[int, int, int, int]\n| datetime.time\n| datetime.datetime\n)\ndef rand_time(\nstart: Timelike | None = None, end: Timelike | None = None\n) -&gt; datetime.time\n</code></pre> <p>Returns a random date between <code>start</code> and <code>end</code> (both inclusive).</p> <p>The inputs can be of the following types:</p> <ul> <li>ISO format string (e.g. <code>\"12:34:56.789012\"</code>)</li> <li>hour integer</li> <li>2\u20134 integer (hour, minute, second, microsecond) tuple (only the first two are required)</li> <li><code>datetime.time</code> object</li> <li><code>datetime.datetime</code> object</li> </ul> <p>Both <code>start</code> and <code>end</code> are optional, and default to <code>datetime.time.min</code> (midnight) and <code>datetime.time.max</code> (<code>23:59:59.999999</code>), respectively.</p>"},{"location":"distributions/","title":"Real-valued distributions","text":""},{"location":"distributions/#ixiabeta_variate","title":"<code>ixia.beta_variate</code>","text":"<p>Link: Original section for <code>random.betavariate</code></p> <pre><code>def beta_variate(alpha: Number, beta: Number) -&gt; float\n</code></pre> <p>Beta distribution.</p> <p>Conditions on the parameters are <code>alpha &gt; 0</code> and <code>beta &gt; 0</code>. Returned values range between $0$ and $1$.</p>"},{"location":"distributions/#ixiabinomial_variate","title":"<code>ixia.binomial_variate</code>","text":"<p>Link: Original section for <code>random.binomialvariate</code></p> <p>Binomial random variable.</p> <p>Gives the number of successes for <code>n</code> independent trials with the probability of success in each trial being <code>p</code>.</p> <p>Equivalent to <code>sum(random() &lt; p for _ in range(n))</code>.</p> <p>Returns an integer in the range $[0, n]$.</p>"},{"location":"distributions/#ixiaexpo_variate","title":"<code>ixia.expo_variate</code>","text":"<p>Link: Original section for <code>random.expovariate</code></p> <pre><code>def expo_variate(lambda_: float = 1.0) -&gt; float\n</code></pre> <p>Exponential distribution.</p> <p><code>lambda_</code> is $1$ divided by the desired mean. It should be nonzero. Returned values are in range $[0, +\\infty)$ for <code>lambda_ &gt; 0</code>, and $(-\\infty, 0]$ for <code>lambda_ &lt; 0</code>.</p>"},{"location":"distributions/#ixiagamma_variate","title":"<code>ixia.gamma_variate</code>","text":"<p>Link: Original section for <code>random.gammavariate</code></p> <pre><code>def gamma_variate(alpha: Number, beta: Number) -&gt; float\n</code></pre> <p>Gamma distribution.</p> <p>Conditions on the parameters are <code>alpha &gt; 0</code> and <code>beta &gt; 0</code>.</p> <p>The probability distribution function is $$f(x)=\\frac{x^{\\alpha-1}\\cdot e^{\\frac{-x}{\\beta}}}{\\Gamma(\\alpha)\\cdot\\beta^\\alpha}$$</p>"},{"location":"distributions/#ixiagauss","title":"<code>ixia.gauss</code>","text":"<p>Link: Original section for <code>random.gauss</code></p> <pre><code>def gauss(mu: Number, sigma: Number) -&gt; float\n</code></pre> <p>Normal distribution, also called the Gaussian distribution.</p> <p><code>mu</code> is the mean, and <code>sigma</code> is the standard deviation. This is slightly faster than the <code>ixia.normal_variate()</code> function.</p> <p>Multithreading Note When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in two ways: 1. Put locks around all calls 2. Use the slower, but thread-safe <code>ixia.normal_variate()</code> function instead.</p>"},{"location":"distributions/#ixialog_norm_variate","title":"<code>ixia.log_norm_variate</code>","text":"<p>Link: Original section for <code>random.lognormvariate</code></p> <pre><code>def log_norm_variate(mu: Number, sigma: Number) -&gt; float\n</code></pre> <p>Log normal distribution.</p> <p>If you take the natural logarithm of this distribution, you'll get a normal distribution with mean <code>mu</code> and standard deviation <code>sigma</code>. <code>mu</code> can have any value, and <code>sigma</code> must be greater than $0$.</p>"},{"location":"distributions/#ixianormal_variate","title":"<code>ixia.normal_variate</code>","text":"<p>Link: Original section for <code>random.normalvariate</code></p> <pre><code>def normal_variate(mu: Number, sigma: Number) -&gt; float\n</code></pre> <p>Normal distribution.</p> <p><code>mu</code> is the mean, and <code>sigma</code> is the standard deviation.</p>"},{"location":"distributions/#ixiapareto_variate","title":"<code>ixia.pareto_variate</code>","text":"<p>Link: Original section for <code>random.paretovariate</code></p> <pre><code>def pareto_variate(alpha: Number) -&gt; float\n</code></pre> <p>Pareto distribution.</p> <p><code>alpha</code> is the shape parameter.</p>"},{"location":"distributions/#ixiarandom","title":"<code>ixia.random</code>","text":"<p>Link: Original section for <code>random.random</code></p> <pre><code>def random() -&gt; float\n</code></pre> <p>Generates a random floating point number in the range $[0, 1)$.</p>"},{"location":"distributions/#ixiatriangular","title":"<code>ixia.triangular</code>","text":"<p>Link: Original section for <code>random.triangular</code></p> <pre><code>def triangular(\nlow: float = 0.0,\nhigh: float = 1.0,\nmode: float | None = None\n) -&gt; float\n</code></pre> <p>Returns a random floating point number <code>N</code> such that <code>low &lt;= N &lt;= high</code> and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution.</p>"},{"location":"distributions/#ixiauniform","title":"<code>ixia.uniform</code>","text":"<p>Link: Original section for <code>random.uniform</code></p> <pre><code>def uniform(a: Number, b: Number) -&gt; float\n</code></pre> <p>Returns a random floating point number <code>N</code> such that <code>a &lt;= N &lt;= b</code> for <code>a &lt;= b</code> and <code>b &lt;= N &lt;= a</code> for <code>b &lt; a</code>.</p> <p>The end-point value b may or may not be included in the range depending on floating-point rounding in the equation <code>a + (b-a) * random()</code>.</p>"},{"location":"distributions/#ixiavon_mises_variate","title":"<code>ixia.von_mises_variate</code>","text":"<p>Link: Original section for <code>random.vonmisesvariate</code></p> <pre><code>def von_mises_variate(mu: Number, kappa: Number) -&gt; float\n</code></pre> <p><code>mu</code> is the mean angle, expressed in radians between $0$ and $\\tau$, and <code>kappa</code> is the concentration parameter, which must be greater than or equal to zero. If <code>kappa</code> is equal to zero, this distribution reduces to a uniform random angle over the range $0$ to $\\tau$.</p>"},{"location":"distributions/#ixiaweibull_variate","title":"<code>ixia.weibull_variate</code>","text":"<p>Link: Original section for <code>random.weibullvariate</code></p> <pre><code>def weibull_variate(alpha: Number, beta: Number) -&gt; float\n</code></pre> <p>Weibull distribution.</p> <p><code>alpha</code> is the scale parameter and <code>beta</code> is the shape parameter.</p>"},{"location":"integers/","title":"Integers","text":""},{"location":"integers/#ixiarand_below","title":"<code>ixia.rand_below</code>","text":"<p>Link: Original section for <code>secrets.randbelow</code></p> <pre><code>def rand_below(n: int) -&gt; int\n</code></pre> <p>Returns a random int in the range $[0, n)$.</p>"},{"location":"integers/#ixiarand_bits","title":"<code>ixia.rand_bits</code>","text":"<p>Link: Original section for <code>random.getrandbits</code></p> <pre><code>def rand_bits(k: int) -&gt; int\n</code></pre> <p>Returns a non-negative Python integer with <code>k</code> random bits.</p>"},{"location":"integers/#ixiarand_bool","title":"<code>ixia.rand_bool</code>","text":"<pre><code>def rand_bool() -&gt; bool\n</code></pre> <p>Returns a random bool.</p>"},{"location":"integers/#ixiarand_int","title":"<code>ixia.rand_int</code>","text":"<p>Link: Original section for <code>random.randint</code></p> <pre><code>def rand_int(a: int, b: int) -&gt; int\n</code></pre> <p>Returns a random integer <code>N</code> in the range $[a, b]$. Alias for <code>ixia.rand_range(a, b+1)</code>.</p>"},{"location":"integers/#ixiarand_ints","title":"<code>ixia.rand_ints</code>","text":"<pre><code>def rand_ints(a: int, b: int, *, k: int) -&gt; list[int]\n</code></pre> <p>Returns a list of <code>k</code> random integrs in the range $[a, b]$. Equivalent to <code>[rand_int(a, b) for _ in range(k)]</code>.</p>"},{"location":"integers/#ixiarand_range","title":"<code>ixia.rand_range</code>","text":"<p>Link: Original section for <code>random.randrange</code></p> <pre><code>def rand_range(start: int, stop: int | None = None, step: int = 1) -&gt; int\n</code></pre> <p>Returns a randomly selected element from <code>range(start, stop, step)</code>. This is equivalent to <code>ixia.choice(range(start, stop, step))</code>, but doesn't actually build a range object.</p> <p>The positional argument pattern matches that of <code>range()</code>. Keyword arguments should not be used because the function may use them in unexpected ways.</p>"},{"location":"integers/#ixiauniverse_rand","title":"<code>ixia.universe_rand</code>","text":"<pre><code>def universe_rand() -&gt; int\n</code></pre> <p>Generates a random number based on the universe.</p> <p>Thanks to the work of the recent Nobel Prize laureates, it was possible to code this function that computes a random number by simulating universe dimensions phasing on gamma ray emission using the sum of the spins of the pair positron/electron in a normalized Higgs field. Surprisingly, Taylor series is involved in this beautiful mathematical operation. It may or may not always return 42, we do not know.</p>"},{"location":"sequences/","title":"Sequences","text":""},{"location":"sequences/#ixiachoice","title":"<code>ixia.choice</code>","text":"<p>Link: Original section for <code>random.choices</code></p> <pre><code>def choice(\nseq: Sequence[T],\nweights: Sequence[Number] | None = None,\n*,\ncumulative_weights: Sequence[Number] | None = None\n) -&gt; T\n</code></pre> <p>Chooses a random element from a non-empty sequence <code>seq</code>.</p> <p>If the relative weights or cumulative weights are not specified, the selections are made with equal probability.</p> <p>If <code>seq</code> is empty, <code>IndexError</code> is raised.</p>"},{"location":"sequences/#ixiachoices","title":"<code>ixia.choices</code>","text":"<p>Link: Original section for <code>random.choices</code></p> <pre><code>def choices(\nseq: Sequence[T],\nweights: Sequence[Number] | None = None,\n*,\ncumulative_weights: Sequence[Number] | None = None,\nk: int = 1,\n) -&gt; list[T]\n</code></pre> <p>Returns a k sized list of elements chosen from the sequence <code>seq</code> with replacement. If the sequence is empty, <code>IndexError</code> is raised.</p> <p>If a <code>weights</code> sequence is specified, selections are made according to the relative weights. Alternatively, if a <code>cumulative_weights</code> sequence is given, the selections are made according to the cumulative weights (perhaps computed using <code>itertools.accumulate()</code>). For example, the relative weights <code>[10, 5, 30, 5]</code> are equivalent to the cumulative weights <code>[10, 15, 45, 50]</code>. Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work.</p> <p>If neither <code>weights</code> nor <code>cumulative_weights</code> are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the <code>seq</code> sequence. Specifying both <code>weights</code> and <code>cumulative_weights</code> will raise a <code>TypeError</code>.</p> <p>The <code>weights</code> or <code>cumulative_weights</code> can use any numeric type that interoperates with the <code>float</code> values returned by <code>ixia.random()</code> (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. If all weights are zero, a <code>ValueError</code> is raised.</p>"},{"location":"sequences/#ixiarand_ints","title":"<code>ixia.rand_ints</code>","text":"<p>Link: See the Integers section.</p>"},{"location":"sequences/#ixiasample","title":"<code>ixia.sample</code>","text":"<p>Link: Original section for <code>random.sample</code></p> <pre><code>def sample(\nseq: Sequence[T],\nk: int,\n*,\ncounts: Iterable[int] | None = None\n) -&gt; list[T]\n</code></pre> <p>Returns a <code>k</code> length list of unique elements chosen from the sequence <code>seq</code>, while keeping the original sequence unchanged. Used for random sampling without replacement.</p> <p>The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices).</p> <p>Members of the sequence don't need to be hashable nor unique. If the sequence contains repeats, then each occurrence is a possible selection in the sample.</p> <p>Repeated elements can be specified one at a time or with the optional keyword-only <code>counts</code> parameter. For example, <pre><code>sample([\"red\", \"blue\"], counts=[4, 2], k=5)\n</code></pre> is equivalent to <pre><code>sample([\"red\", \"red\", \"red\", \"red\", \"blue\", \"blue\", k=5])\n</code></pre> To choose a sample from a range of integers, use a <code>range()</code> object as an argument. This is especially fast and space efficient for sampling from a large population: <pre><code>sample(range(10 ** 7), k=60)\n</code></pre></p> <p>If the sample size is larger than the population size, a <code>ValueError</code> is raised.</p>"},{"location":"sequences/#ixiashuffle","title":"<code>ixia.shuffle</code>","text":"<p>Link: Original section for <code>random.shuffle</code></p> <pre><code>def shuffle(seq: MutableSequence[Any]) -&gt; None\n</code></pre> <p>Shuffles the sequence <code>seq</code> in place.</p> <p>For out of place shuffling, use <code>ixia.shuffled()</code>.</p>"},{"location":"sequences/#ixiashuffled","title":"<code>ixia.shuffled</code>","text":"<pre><code>def shuffled(seq: Sequence[T]) -&gt; MutableSequence[T]\n</code></pre> <p>Shuffles the sequence <code>seq</code> out of place.</p> <p>If <code>seq</code> is a mutable type <code>M[T]</code>, the function will return <code>M[T]</code>. If <code>seq</code> is an immutable type <code>IM[T]</code>, the function will return <code>list[T]</code>.</p> <p>For in place shuffling, use <code>ixia.shuffle()</code>.</p>"},{"location":"strings_and_bytes/","title":"Strings and bytes","text":""},{"location":"strings_and_bytes/#ixiapassphrase","title":"<code>ixia.passphrase</code>","text":"<pre><code>def passphrase(\nn: int, *, sep: str = \"-\", words_path: str = \"/usr/share/dict/words\"\n) -&gt; str\n</code></pre> <p>Generates an XKCD-style passphrase made up from <code>n</code> words (based on the file specified by <code>words_path</code>), separated by <code>sep</code> (<code>-</code> by default).</p> <p>\u26a0\ufe0f The default word list is not available on Windows.</p>"},{"location":"strings_and_bytes/#ixiarand_bytes","title":"<code>ixia.rand_bytes</code>","text":"<p>Link: Original section for <code>random.randbytes</code></p> <pre><code>def rand_bytes(n: int = 32) -&gt; bytes\n</code></pre> <p>Generates <code>n</code> random bytes. Defaults to 32.</p>"},{"location":"strings_and_bytes/#ixiarand_hex","title":"<code>ixia.rand_hex</code>","text":"<p>Link: Original section for <code>secrets.token_hex</code></p> <pre><code>def rand_hex(n: int) -&gt; str\n</code></pre> <p>Returns a hex string composed of <code>n</code> random bytes.</p>"},{"location":"strings_and_bytes/#ixiarand_line","title":"<code>ixia.rand_line</code>","text":"<p><pre><code>def rand_line(file: TextIOBase | str) -&gt; str\n</code></pre> Returns a random line from a file. Given a string, assumes it is a path, reads it, and returns a random line from the read content. Given a readable IO object, reads it, and returns a random line from the read content.</p>"},{"location":"strings_and_bytes/#ixiarand_urlsafe","title":"<code>ixia.rand_urlsafe</code>","text":"<p>Original section for <code>secrets.token_urlsafe</code></p> <pre><code>def rand_urlsafe(n: int = 32) -&gt; str\n</code></pre> <p>Returns a random URL-safe text string, composed of <code>n</code> bytes, in Base64 encoding. Defaults to 32.</p>"}]}